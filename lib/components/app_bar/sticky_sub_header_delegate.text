lógica para barrinha preta animada

O que devo ter em mente.

1) o Stack

Para desenvolver isso eu não posso simplesmente colocar uma barra embaixo da outra numa coluna por exemplo.

Elas precisam estar em uma stack (pilha);

Essa pilha vai conter a camada de cima que é a Bar() e a camada de baixo que vai ser a mini barra.

Assim:

Como a appbar é opaca e está na frente, a mini barra vai poder deslizar para trás da barra principal causando o efeito de desaparecer


2) A geometria do scroll

Para fazer o header ser persistente ele deve trabalhar com dois limites, que é a altura máxima que esse header vai possuir juntando as 2 barras e altura que vai restar quando eu rolar e a mini barra desaparecer.

 - maxExtent: altura total do componente quando ta no topo da página (AppBar + mini barra)
 - minExtent: altura que sobre quando rolado (AppBar apenas)

é muito importante ter em mente a variação entre esses dois tamanhos, por exemplo, a AppBar tem 80px, se a mini barra tiver 40px, o tamanho do header varia de 120px para 80px.


3) A variável Mestra shrinkOffset

a chave é essa variável que é um número que o flutter entrega que diz a quantidade de pixels que o usuário já rolou pra dentro do header.

A lógica matemática para conseguir isso se dá por uma porcentagem resultada pela fórmula que é valor subtraído de maxExtent por minExtent dividido pelo valor que o flutter entregou de shrinkOffset.

Se o resultado dessa fórmula for 0.0 o usuário está no topo (barra totalmente visível)
Se o resultado for 1.0 a mini barra já sumiu completamente

4) Lógica de animação (interpolação)

Com o resultado dessa fórmula na mão não é necessário usar setState ou Timers. as propriedades visuais são vinculadas a esses números

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

class CombinedHeaderDelegate extends SliverPersistentHeaderDelegate {
  final double badgeOpacity;

  CombinedHeaderDelegate({required this.badgeOpacity});

  @override
  double get minExtent => 80.0; // Altura da AppBar principal
  @override
  double get maxExtent => 125.0; // AppBar principal (80) + Mini barra (45)

  @override
  Widget build(BuildContext context, double shrinkOffset, bool overlapsContent) {
    // Calcula a porcentagem de quanto a barra já encolheu (0.0 a 1.0)
    final double shrinkPercentage = (shrinkOffset / (maxExtent - minExtent)).clamp(0.0, 1.0);
    
    // Inverte para termos a opacidade da mini barra
    final double miniBarOpacity = 1.0 - shrinkPercentage;

    return Container(
      color: Colors.black,
      child: Stack(
        children: [
          // 1. Mini Barra (Fica por "trás" na pilha, mas posicionada abaixo)
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Opacity(
              opacity: miniBarOpacity,
              child: Transform.translate(
                // Faz o efeito de "subir" para dentro da barra principal
                offset: Offset(0, -20 * shrinkPercentage), 
                child: _buildMiniBar(),
              ),
            ),
          ),
          
          // 2. AppBar Principal (Fica por cima de tudo)
          const BarContent(), 
        ],
      ),
    );
  }

  Widget _buildMiniBar() {
    return Container(
      height: 45,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: Colors.black,
        border: Border(top: BorderSide(color: Colors.grey[900]!, width: 0.5))
      ),
      child: Row(
        children: [
          const Icon(Icons.star, color: Colors.amber, size: 15.0),
          const SizedBox(width: 3),
          const Text(
            'Campanhas',
            style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 15),
          ),
          const SizedBox(width: 24),
          Text(
            'Meus títulos',
            style: TextStyle(color: Colors.grey[500], fontSize: 15),
          ),
        ],
      ),
    );
  }

  @override
  bool shouldRebuild(covariant CombinedHeaderDelegate oldDelegate) {
    return oldDelegate.badgeOpacity != badgeOpacity;
  }
}


----------------------------------------------------------------

class Bar extends StatelessWidget {
  const Bar({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 80,
      color: Colors.black,
      padding: EdgeInsets.only(top: MediaQuery.of(context).padding.top),
      child: NavigationToolbar(
        leading: IconButton(
          icon: const Icon(Icons.sort, color: Colors.white),
          onPressed: () { /* Sua função de abrir menu */ },
        ),
        centerMiddle: true,
        middle: Image.asset('assets/icons/codetech.png', height: 45),
        trailing: [
           // Seus widgets de suporte aqui...
        ],
      ),
    );
  }
}